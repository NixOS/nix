#! /usr/bin/perl -w

use strict;
my $hash = $ARGV[0];
$hash || die "no package hash specified";

my $prefix = $ENV{"NIX"} || "/nix"; # !!! use prefix
my $linkdir = "$prefix/var/nix/links";

# Build the specified package, and all its dependencies.
my $pkgdir = `nix getpkg $hash`;
if ($?) { die "`nix getpkg' failed"; }
chomp $pkgdir;

my $id = `nix info $hash | cut -c 34-`;
if ($?) { die "`nix info' failed"; }
chomp $id;

# Figure out a generation number.
my $nr = 0;
while (-e "$linkdir/$id-$nr") { $nr++; }
my $link = "$linkdir/$id-$nr";
print "$pkgdir\n";

# Create a symlink from $link to $pkgdir.
symlink($pkgdir, $link) or die "cannot create $link";

# Make $link the current generation by pointing $linkdir/current to
# it.  The rename() system call is supposed to be essentially atomic
# on Unix.  That is, if we have links `current -> X' and `new_current
# -> Y', and we rename new_current to current, a process accessing
# current will see X or Y, but never a file-not-found or other error
# condition.  This is sufficient to atomically switch the current link
# tree.

my $current = "$linkdir/current";

print "switching $current to $link\n";

my $tmplink = "$linkdir/new_current";
symlink($link, $tmplink) or die "cannot create $tmplink";
rename($tmplink, $current) or die "cannot rename $tmplink";
