#! @perl@ -w -I@libexecdir@/nix

use strict;
use IPC::Open2;
use POSIX qw(tmpnam);
use readmanifest;

my $tmpdir;
do { $tmpdir = tmpnam(); }
until mkdir $tmpdir, 0777;

my $nixfile = "$tmpdir/create-nars.nix";
my $manifest = "$tmpdir/MANIFEST";

END { unlink $manifest; unlink $nixfile; rmdir $tmpdir; }

my $curl = "@curl@ --fail --silent";
my $extraCurlFlags = ${ENV{'CURL_FLAGS'}};
$curl = "$curl $extraCurlFlags" if defined $extraCurlFlags;

my $binDir = $ENV{"NIX_BIN_DIR"};
$binDir = "@bindir@" unless defined $binDir;

my $dataDir = $ENV{"NIX_DATA_DIR"};
$dataDir = "@datadir@" unless defined $dataDir;


# Parse the command line.
my $localCopy;
my $localArchivesDir;
my $localManifestFile;

my $archives_put_url;
my $archives_get_url;
my $manifest_put_url;

if ($ARGV[0] eq "--copy") {
    die "syntax: nix-push --copy ARCHIVES_DIR MANIFEST_FILE PATHS...\n" if scalar @ARGV < 3;
    $localCopy = 1;
    shift @ARGV;
    $localArchivesDir = shift @ARGV;
    $localManifestFile = shift @ARGV;
}
else {
    die "syntax: nix-push ARCHIVES_PUT_URL ARCHIVES_GET_URL " .
        "MANIFEST_PUT_URL PATHS...\n" if scalar @ARGV < 3;
    $localCopy = 0;
    $archives_put_url = shift @ARGV;
    $archives_get_url = shift @ARGV;
    $manifest_put_url = shift @ARGV;
}


# From the given store paths, determine the set of requisite store
# paths, i.e, the paths required to realise them.
my %storePaths;

foreach my $path (@ARGV) {
    die unless $path =~ /^\//;

    # Get all paths referenced by the normalisation of the given 
    # Nix expression.
    my $pid = open2(\*READ, \*WRITE,
        "$binDir/nix-store --query --requisites --force-realise " .
        "--include-outputs '$path'") or die;
    close WRITE;
    
    while (<READ>) {
        chomp;
        die "bad: $_" unless /^\//;
        $storePaths{$_} = "";
    }
    close READ;
    
    waitpid $pid, 0;
    $? == 0 or die "nix-store failed";
}

my @storePaths = keys %storePaths;


# For each path, create a Nix expression that turns the path into
# a Nix archive.
open NIX, ">$nixfile";
print NIX "[";

foreach my $storePath (@storePaths) {
    die unless ($storePath =~ /\/[0-9a-z]{32}.*$/);

    # Construct a Nix expression that creates a Nix archive.
    my $nixexpr = 
        "((import $dataDir/nix/corepkgs/nar/nar.nix) " .
        "{path = \"$storePath\"; system = \"@system@\";}) ";
    
    print NIX $nixexpr;
}

print NIX "]";
close NIX;


# Instantiate store expressions from the Nix expression.
my @storeexprs;
print STDERR "instantiating store expressions...\n";
open STOREEXPRS, "$binDir/nix-instantiate $nixfile |" or die "cannot run nix-instantiate";
while (<STOREEXPRS>) {
    chomp;
    die unless /^\//;
    push @storeexprs, $_;
}
close STOREEXPRS;


# Realise the store expressions.
print STDERR "creating archives...\n";

my @narpaths;

my @tmp = @storeexprs;
while (scalar @tmp > 0) {
    my $n = scalar @tmp;
    if ($n > 256) { $n = 256 };
    my @tmp2 = @tmp[0..$n - 1];
    @tmp = @tmp[$n..scalar @tmp - 1];

    open NARPATHS, "$binDir/nix-store --realise @tmp2 |" or die "cannot run nix-store";
    while (<NARPATHS>) {
        chomp;
        die unless (/^\//);
        push @narpaths, "$_";
    }
    close NARPATHS;
}


# Create the manifest.
print STDERR "creating manifest...\n";

my %narFiles;
my %patches;
my %successors;

my @nararchives;
for (my $n = 0; $n < scalar @storePaths; $n++) {
    my $storePath = $storePaths[$n];
    my $nardir = $narpaths[$n];
    
    $storePath =~ /\/([^\/]*)$/;
    my $basename = $1;
    defined $basename or die;

    my $narname = "$basename.nar.bz2";

    my $narfile = "$nardir/$narname";
    (-f $narfile) or die "narfile for $storePath not found";
    push @nararchives, $narfile;

    open MD5, "$nardir/narbz2-hash" or die "cannot open narbz2-hash";
    my $narbz2Hash = <MD5>;
    chomp $narbz2Hash;
    $narbz2Hash =~ /^[0-9a-z]{32}$/ or die "invalid hash";
    close MD5;

    open MD5, "$nardir/nar-hash" or die "cannot open nar-hash";
    my $narHash = <MD5>;
    chomp $narHash;
    $narHash =~ /^[0-9a-z]{32}$/ or die "invalid hash";
    close MD5;
    
    my $narbz2Size = (stat $narfile)[7];

    my $references = join(" ", split(" ", `$binDir/nix-store --query --references '$storePath'`));

    my $url;
    if ($localCopy) {
        $url = "file://$localArchivesDir/$narname";
    } else {
        $url = "$archives_get_url/$narname";
    }
    $narFiles{$storePath} = [
        { url => $url
        , hash => $narbz2Hash
        , size => $narbz2Size
        , narHash => $narHash
        , hashAlgo => "sha1"
        , references => $references
        }
    ];
                            
    if ($storePath =~ /\.store$/) {
        open PREDS, "$binDir/nix-store --query --predecessors $storePath |" or die "cannot run nix";
        while (<PREDS>) {
            chomp;
            die unless (/^\//);
            my $pred = $_;
            # Only include predecessors that are themselves being
            # pushed.
            if (defined $storePaths{$pred}) {
                $successors{$pred} = $storePath;
            }
        }
        close PREDS;
    }

}

writeManifest $manifest, \%narFiles, \%patches, \%successors;


sub copyFile {
    my $src = shift;
    my $dst = shift;
    system("cp '$src' '$dst.tmp'") == 0 or die "cannot copy file";
    rename("$dst.tmp", "$dst") or die "cannot rename file";
}


# Upload the archives.
print STDERR "uploading archives...\n";
foreach my $nararchive (@nararchives) {

    $nararchive =~ /\/([^\/]*)$/;
    my $basename = $1;

    if ($localCopy) {
        if (! -f "$localArchivesDir/$basename") {
            print STDERR "  $nararchive\n";
            copyFile $nararchive, "$localArchivesDir/$basename";
        }
    }
    else {
        if (system("$curl --head $archives_get_url/$basename > /dev/null") != 0) {
            print STDERR "  $nararchive\n";
            system("$curl --show-error --upload-file " .
                   "'$nararchive' '$archives_put_url/$basename' > /dev/null") == 0 or
                   die "curl failed on $nararchive: $?";
        }
    }
}


# Upload the manifest.
print STDERR "uploading manifest...\n";
if ($localCopy) {
    copyFile $manifest, $localManifestFile;
} else {
    system("$curl  --show-error --upload-file " .
           "'$manifest' '$manifest_put_url' > /dev/null") == 0 or
           die "curl failed on $manifest: $?";
}
